Whiteboard Platform Overview (Backend + Frontend)
===============================================

Backend (Spring Boot)
---------------------
1. Entry & Build System
   - `WhiteboardAppApplication.java` boots the Spring context and wires every component via classpath scanning.
   - `pom.xml` declares Spring Web, Data JPA, WebSocket, PostgreSQL, H2 (dev), Lombok, and the testing stack; targets Java 21 and configures compiler + Boot plugins.

2. Configuration Layer (`config/`)
   - `CorsConfig` / `WebConfig`: extend `WebMvcConfigurer` to allow localhost React origins for REST (`/api/**`) and WebSocket (`/ws/**`).
   - `WebSocketConfig`: enables STOMP messaging with `/app` (client → server) and `/topic` (server → client) prefixes, boosts message size/time limits, and registers the SockJS endpoint (`/ws`).
   - `WebSocketInterceptor`: decorates handlers to log connection establishment/closure for operability.

3. Controllers (`controller/`)
   - `SessionController`: REST endpoints to create/join sessions, list channels, and fetch or post chat/draw history; converts entities to DTOs (`SessionResponseDTO`, `ChannelDTO`).
   - `WebSocketController`: `@MessageMapping` handlers for `/draw/{session}/{channel}` and `/chat/...`; persists via `WhiteboardService` and echoes payloads to `/topic/whiteboard/...` or `/topic/chat/...` so subscribers update live.
   - `RecoveryController`: admin APIs to inspect fallback storage health, trigger replay of offline events, back up, or clear the file.

4. DTOs (`dto/`)
   - Request DTOs (`CreateSessionRequest`, `JoinSessionRequest`, `ChatPayload`) capture REST payloads.
   - `ChannelDTO` + `SessionResponseDTO` deliver channel counts and participant lists without heavy entity graphs.

5. Domain Model (`model/`)
   - `WhiteboardSession`: JPA entity with unique `sessionName`, embedded `SessionManager`, and one-to-many `Participant` + `Channel` collections.
   - `Participant`: entity referencing its session (lazy + `@JsonBackReference`).
   - `Channel`: owns `List<DrawPayload>` and `List<ChatMessage>` as element collections plus the `session` back-link.
   - `DrawPayload` + `ChatMessage`: `@Embeddable` value types mirroring frontend JSON shapes.

6. Persistence & Storage
   - `WhiteboardSessionRepository`: JPA repository with `findBySessionName`.
   - `PersistenceWorker`: bounded queue + single-thread executor ensuring serialized DB writes; wraps operations in Spring transactions and falls back to file storage on failure.
   - `FallbackStorage`: appends JSON Lines to `data/offline-persist.jsonl`, can back up/clear, provides stats, and exposes `FallbackEvent` records for replay.

7. Service Layer (`WhiteboardService`)
   - Starts/stops `PersistenceWorker` (lifecycle hooks).
   - `createSession` seeds a session with a “general” channel; `joinSession` enforces uniqueness.
   - `addShape` ignores preview events, handles `clear` synchronously, and enqueues final draw events.
   - `postChatMessage` timestamps chat payloads, enqueues persistence, and returns immediately for optimistic UI.
   - `getChatMessages` / `getShapes` eagerly initialize lazy collections; `replayFallbackEvents` rehydrates DB state from fallback file.

8. Exception Handling (`exception/`)
   - Custom hierarchy (`WhiteboardException`, `SessionException`, `PersistenceException`, `SocketCommunicationException`).
   - `RestExceptionhandler` maps each type to structured JSON responses with consistent HTTP codes.

9. Resources & Logging
   - `application.properties` toggles `prod` profile, sets server/WebSocket limits, Hibernate batching, and logging levels.
   - `application-prod.properties` wires the Supabase PostgreSQL DSN; dev profile relies on default H2.
   - `logback-spring.xml` defines console/file/async appenders and verbosity per package.

10. Tests (`src/test/...`)
    - `WhiteboardAppApplicationTests`: context smoke test.
    - `WhiteboardServiceTests`: integration tests for create/join flows and error cases.
    - `SessionControllerIntegrationTests`: REST-level create/join scenario via `TestRestTemplate` on a random port.

Frontend (React SPA)
--------------------
1. Project Setup
   - CRA-based (`react-scripts`), React 19, React Router 7, STOMP, SockJS, Testing Library.
   - `.env.local` defines `REACT_APP_API_URL` + `REACT_APP_WS_URL` (default `http://localhost:8081`).
   - `setupProxy.js` tunnels `/api` and `/ws` calls from the dev server to the Spring backend with WebSocket support.

2. App Shell
   - `index.js` renders `<App />` within `StrictMode`.
   - `App.js` handles routing between `/login` and `/whiteboard`, restores saved sessions from `SessionPersistence`, and guards routes with `<Navigate>` redirects.

3. Session & Offline Persistence
   - `SessionPersistence.js`: localStorage helper to save/restore/clear `{sessionName,userName,channelName}` payloads.
   - `StorageService.js`: IndexedDB wrapper that caches DRAW/CHAT events per session/channel, merges cached vs server history, and can clear/report stats per channel.

4. Login Flow (`LoginPage.js` + CSS)
   - Form toggles between create/join, validates input, fetches available channels when joining, calls REST APIs, and reports errors.
   - On success, determines available channels and calls `onLogin` with the chosen one.

5. Main Whiteboard (`WhiteboardPage.js` + CSS)
   - On mount, loads history via REST (`/shapes`, `/chat`) or falls back to IndexedDB cache; afterwards establishes a STOMP connection using `Client` + SockJS factory with reconnect/heartbeat.
   - Subscribes to `/topic/whiteboard/{session}/{channel}` and `/topic/chat/...`; handlers dedupe events, handle `clear`, cache incoming data, and reconcile optimistic chat entries.
   - Provides channel switching (reloads history + resubscribes), live connection status, and logout button.
   - Layout renders `ChannelSelector`, `Canvas`, and `Chat` components side-by-side.

6. Canvas (`Canvas.js` + CSS)
   - Maintains toolbar state (color, line width, background, pen/line/rect/circle/eraser).
   - Uses pointer events and dual canvases (main + overlay) to support freehand drawing, geometric shapes, erasing, and clear-all.
   - Immediately draws locally for responsiveness, updates parent state (`addLocalDrawEvent`), and publishes events via `sendDrawEvent`.
   - Listens for remote preview/final events to update the overlay/history; clears caches on `clear` messages.

7. Chat (`Chat.js` + CSS)
   - Displays chat history with timestamps, auto-scrolls, and uses optimistic messages until the server echo replaces them.
   - Sends messages via `sendChatMessage`, which publishes STOMP payloads and caches them offline.

8. Channel Selector (`ChannelSelector.js` + CSS)
   - Fetches channel list (`/api/sessions/{session}/channels`), shows message/shape counts, and lets users switch channels via dropdown.

End-to-End Interaction
----------------------
1. Login/Create Session
   - Frontend POSTs to `/api/sessions/create|join` → `SessionController` → `WhiteboardService` → `WhiteboardSessionRepository`.
   - Response DTO seeds React state and local storage.

2. Channel Metadata
   - `ChannelSelector` fetches `/api/sessions/{session}/channels`; backend maps channels to DTO counts for UI display.

3. History Loading
   - `WhiteboardPage` calls `/shapes` + `/chat`; `WhiteboardService` fetches linked collections, forcing lazy init. If offline/unavailable, `StorageService` supplies cached IndexedDB events.

4. Real-Time Collaboration
   - `Canvas` / `Chat` publish events to `/app/draw` or `/app/chat` over STOMP.
   - `WebSocketController` persists via `WhiteboardService`, which enqueues `PersistenceWorker` tasks; tasks update `Channel` collections and save the owning session. Failures trigger `FallbackStorage` writes.
   - Successful DB writes (or fallback) lead to broadcasts on `/topic/whiteboard/...` or `/topic/chat/...`, which all clients consume and cache offline.

5. Fallback & Recovery
   - If DB persistence fails, events are appended to `offline-persist.jsonl`.
   - `RecoveryController` endpoints expose status, replay the backlog (`WhiteboardService.replayFallbackEvents`), back up, or clear the file once DB health is restored.

This document mirrors the detailed explanation across every backend class and frontend component so it can be used for viva/knowledge-transfer discussions.
